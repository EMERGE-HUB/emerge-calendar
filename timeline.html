<!-- timeline.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EMERGE – Timeline (WPs + Holidays)</title>

  <!-- vis-timeline (self-hosted) -->
  <link rel="stylesheet" href="/vendor/vis-timeline-graph2d.min.css">

  <script src="/vendor/moment.min.js"></script>
  <script src="/vendor/vis-data.min.js"></script>
  <script src="/vendor/vis-timeline-graph2d.min.js"></script>

<script>
  // ============================================================
  // ICS PARSER (adds basic RRULE expansion for FREQ=MONTHLY;UNTIL=...)
  // ============================================================
  function parseICS(icsText) {
    const rawLines = icsText.split(/\r?\n/);
    const lines = [];

    // Unfold lines
    for (const line of rawLines) {
      if (!line) continue;
      if (line.startsWith(' ') || line.startsWith('\t')) {
        if (lines.length > 0) lines[lines.length - 1] += line.slice(1);
      } else {
        lines.push(line);
      }
    }

    const vevents = [];
    let current = null;

    for (const line of lines) {
      if (line.startsWith('BEGIN:VEVENT')) { current = {}; continue; }
      if (line.startsWith('END:VEVENT')) { if (current) vevents.push(current); current = null; continue; }
      if (!current) continue;

      const parts = line.split(':');
      if (parts.length < 2) continue;

      const value = parts.slice(1).join(':');
      const keyWithParams = parts[0];
      const key = keyWithParams.split(';')[0].toUpperCase();

      if (key === 'SUMMARY') current.summary = value;
      if (key === 'DESCRIPTION') current.description = value.replace(/\\n/g, '\n');
      if (key === 'LOCATION') current.location = value;
      if (key === 'DTSTART') current.dtstart = value;
      if (key === 'DTEND') current.dtend = value;
      if (key === 'RRULE') current.rrule = value; // <-- capture RRULE
    }

    function parseICSTime(v) {
      if (!v) return null;

      // All-day date (YYYYMMDD)
      if (v.length === 8 && !v.includes('T')) {
        const y = parseInt(v.slice(0,4), 10);
        const m = parseInt(v.slice(4,6), 10) - 1;
        const d = parseInt(v.slice(6,8), 10);
        return { date: new Date(Date.UTC(y, m, d)), allDay: true, isUTC: true };
      }

      // Date-time (YYYYMMDDTHHMMSS[Z])
      const y = parseInt(v.slice(0,4), 10);
      const m = parseInt(v.slice(4,6), 10) - 1;
      const d = parseInt(v.slice(6,8), 10);
      const hh = parseInt(v.slice(9,11) || '0', 10);
      const mm = parseInt(v.slice(11,13) || '0', 10);
      const ss = parseInt(v.slice(13,15) || '0', 10);

      if (v.endsWith('Z')) return { date: new Date(Date.UTC(y, m, d, hh, mm, ss)), allDay: false, isUTC: true };
      return { date: new Date(y, m, d, hh, mm, ss), allDay: false, isUTC: false };
    }

    function parseRRule(rruleStr) {
      // e.g. "FREQ=MONTHLY;UNTIL=20291204T235959Z"
      const out = {};
      if (!rruleStr) return out;
      rruleStr.split(';').forEach(part => {
        const [k, v] = part.split('=');
        if (!k || !v) return;
        out[k.toUpperCase()] = v;
      });
      return out;
    }

    function addMonths(d, months, useUTC) {
      // keep same clock time
      const y = useUTC ? d.getUTCFullYear() : d.getFullYear();
      const m = (useUTC ? d.getUTCMonth() : d.getMonth()) + months;
      const day = useUTC ? d.getUTCDate() : d.getDate();
      const hh = useUTC ? d.getUTCHours() : d.getHours();
      const mm = useUTC ? d.getUTCMinutes() : d.getMinutes();
      const ss = useUTC ? d.getUTCSeconds() : d.getSeconds();

      if (useUTC) return new Date(Date.UTC(y, m, day, hh, mm, ss));
      return new Date(y, m, day, hh, mm, ss);
    }

    function cloneWithShift(base, start, end, title, props) {
      return {
        title,
        start,
        end,
        allDay: base.allDay,
        extendedProps: props
      };
    }

    // Build events (with RRULE expansion for MONTHLY)
    const events = [];

    for (const ev of vevents) {
      const sp = parseICSTime(ev.dtstart);
      const ep = parseICSTime(ev.dtend);
      if (!sp || !sp.date) continue;

      const base = {
        title: ev.summary || '(no title)',
        allDay: !!sp.allDay,
        extendedProps: { description: ev.description || '', location: ev.location || '' }
      };

      const start0 = sp.date;
      const end0 = ep && ep.date ? ep.date : null;
      const useUTC = !!sp.isUTC; // DTSTART:...Z => use UTC maths

      // No RRULE => single event
      if (!ev.rrule) {
        events.push({
          title: base.title,
          start: start0,
          end: end0,
          allDay: base.allDay,
          extendedProps: base.extendedProps
        });
        continue;
      }

      // RRULE present => expand (MONTHLY only)
      const rule = parseRRule(ev.rrule);
      const freq = (rule.FREQ || '').toUpperCase();
      if (freq !== 'MONTHLY') {
        // fallback: include only base occurrence if unsupported
        events.push({
          title: base.title,
          start: start0,
          end: end0,
          allDay: base.allDay,
          extendedProps: base.extendedProps
        });
        continue;
      }

      const untilParsed = rule.UNTIL ? parseICSTime(rule.UNTIL) : null;
      const until = untilParsed && untilParsed.date ? untilParsed.date : null;

      // Safety cap to avoid runaway
      const MAX_OCCURRENCES = 240; // 20 years monthly
      let count = 0;

      // duration in ms (for timed events)
      const durMs = (end0 && !base.allDay) ? (end0.getTime() - start0.getTime()) : null;

      for (let i = 0; i < MAX_OCCURRENCES; i++) {
        const occStart = addMonths(start0, i, useUTC);
        if (until && occStart.getTime() > until.getTime()) break;

        let occEnd = null;
        if (base.allDay) {
          // all-day: keep DTEND as provided (often same day in your feeds)
          occEnd = end0 ? addMonths(end0, i, useUTC) : null;
        } else if (durMs !== null) {
          occEnd = new Date(occStart.getTime() + durMs);
        }

        events.push(cloneWithShift(base, occStart, occEnd, base.title, base.extendedProps));
        count++;
      }
    }

    return events;
  }
</script>

  
  <style>
    :root{
      --weekend:#f0f2f5;
    }

    body { margin:0; padding:0; font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif; background:#f5f7fb; color:#222; }

    header { background:#004f9f; color:#fff; padding:16px 24px; box-shadow:0 2px 6px rgba(0,0,0,0.2); }
    .header-container { display:flex; align-items:center; gap:16px; }
    .header-logo { background:#fff; padding:6px; border-radius:6px; height:60px; }
    .header-text h1 { margin:0; font-size:1.3rem; }
    .header-text p { margin:4px 0 0; font-size:0.9rem; opacity:0.95; }

    .wp-nav {
      background:#fff;
      padding:10px 20px;
      margin:0 auto 20px;
      display:flex;
      gap:12px;
      align-items:center;
      border-radius:6px;
      box-shadow:0 1px 4px rgba(0,0,0,0.15);
      font-size:0.9rem;
    }
    .wp-nav a { color:#004f9f; text-decoration:none; font-weight:700; padding-bottom:2px; border-bottom:2px solid transparent; }
    .wp-nav a:hover { text-decoration:underline; }
    .wp-nav a.active { border-bottom-color:#004f9f; }

    main { max-width:none; width:100%; margin:16px auto; padding:0 16px 40px; }
    #status { margin-bottom:8px; font-size:0.9rem; color:#555; }
    #status.error { color:#b00020; }

    .card { background:#fff; border-radius:8px; padding:10px; box-shadow:0 2px 10px rgba(0,0,0,0.08); }
    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px; }

    .btn {
      display:inline-block; padding:6px 10px; border-radius:6px; border:1px solid #ccc;
      background:#f3f4f6; cursor:pointer; font-size:0.85rem; font-weight:600;
    }
    .btn:hover { background:#e5e7eb; }

    .togglebar {
      display:flex; flex-wrap:wrap; gap:8px 10px; align-items:center;
      margin-bottom:10px; padding:10px; border:1px solid #e6e8ef; border-radius:8px; background:#fbfcff;
    }
    .toggle {
      display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid #dde2ee;
      border-radius:999px; background:#fff; cursor:pointer; user-select:none; font-size:0.85rem; font-weight:650; color:#111;
    }
    .toggle input { width:16px; height:16px; accent-color:#004f9f; margin:0; }
    .swatch { width:12px; height:12px; border-radius:3px; border:1px solid rgba(0,0,0,0.25); display:inline-block; }

    #timeline { height:calc(100vh - 300px); min-height:520px; width:100%; border:1px solid #e6e8ef; border-radius:8px; }

    /* Weekend shading background items (generated in JS, only on HOLIDAYS row) */
    .vis-item.weekend-bg{
      background: var(--weekend) !important;
      border: none !important;
      border-radius: 0 !important;
      opacity: 1 !important;
      z-index: 0 !important;
    }

    /* Modal */
    .modal-backdrop {
      position:fixed; inset:0; background:rgba(0,0,0,0.4);
      display:flex; align-items:center; justify-content:center;
      visibility:hidden; opacity:0;
      transition:opacity 0.2s ease, visibility 0.2s ease;
      z-index:9999;
    }
    .modal-backdrop.show { visibility:visible; opacity:1; }
    .modal {
      background:#fff; border-radius:10px; max-width:520px; width:92%;
      padding:20px 22px 16px; box-shadow:0 4px 20px rgba(0,0,0,0.25);
    }
    .modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    .modal-title { font-size:1.05rem; font-weight:600; margin:0; }
    .modal-close { border:none; background:transparent; font-size:1.2rem; cursor:pointer; line-height:1; }
    .modal-body p { margin:4px 0; font-size:0.9rem; }
    .modal-body p span.label { font-weight:600; }
    .modal-footer { margin-top:12px; text-align:right; }

    @media (max-width:600px) {
      .header-text h1 { font-size:1.1rem; }
      #timeline { height:calc(100vh - 340px); min-height:420px; }
    }
  </style>
</head>

<body>
<header>
  <div class="header-container">
    <img src="https://euemerge.eu/wp-content/uploads/2025/05/emerge_website.png"
         alt="EMERGE Logo"
         class="header-logo" />
    <div class="header-text">
      <h1>EMERGE – Timeline (WPs + Holidays)</h1>
      <p>Toggle Work Packages and Holidays (ICS feeds)</p>
    </div>
  </div>
</header>

<nav class="wp-nav">
  <a href="index.html" id="homeLink">Home</a>
  <a href="timeline.html" class="active">Timeline</a>
</nav>

<main>
  <div id="status">Loading timeline…</div>

  <div class="card">
    <div class="controls">
      <button class="btn" id="zoomInBtn">Zoom in</button>
      <button class="btn" id="zoomOutBtn">Zoom out</button>
      <button class="btn" id="fitBtn">Fit all</button>
      <button class="btn" id="yearBtn">This year</button>
      <button class="btn" id="showAllBtn">Show all</button>
      <button class="btn" id="hideAllBtn">Hide all</button>
      <button class="btn" id="backBtn">Back to landing page</button>
    </div>

    <div class="togglebar" id="togglebar"></div>

    <div id="timeline"></div>
  </div>
</main>

<!-- Event detail modal -->
<div id="eventModalBackdrop" class="modal-backdrop">
  <div class="modal">
    <div class="modal-header">
      <h2 class="modal-title" id="modalTitle"></h2>
      <button class="modal-close" id="modalCloseBtn" aria-label="Close">&times;</button>
    </div>
    <div class="modal-body">
      <p><span class="label">When:</span> <span id="modalWhen"></span></p>
      <p><span class="label">Source:</span> <span id="modalSource"></span></p>
      <p><span class="label">Location:</span> <span id="modalLocation"></span></p>
      <p><span class="label">Description:</span></p>
      <p id="modalDescription"></p>
    </div>
    <div class="modal-footer">
      <button class="btn" id="modalOkBtn">Close</button>
    </div>
  </div>
</div>

<script>
  // ---------------------------
  // Config
  // ---------------------------
  const ICS_BASE = 'https://pub-577ff589d29c4ebe9d2ea393dcf228f1.r2.dev/';

  const FEEDS = [
    { id: 'WP1', label: 'WP1', url: ICS_BASE + 'wp1.ics', color: '#1f77b4' },
    { id: 'WP2', label: 'WP2', url: ICS_BASE + 'wp2.ics', color: '#ff7f0e' },
    { id: 'WP3', label: 'WP3', url: ICS_BASE + 'wp3.ics', color: '#2ca02c' },
    { id: 'WP4', label: 'WP4', url: ICS_BASE + 'wp4.ics', color: '#d62728' },
    { id: 'WP5', label: 'WP5', url: ICS_BASE + 'wp5.ics', color: '#9467bd' },
    { id: 'WP6', label: 'WP6', url: ICS_BASE + 'wp6.ics', color: '#8c564b' },
    { id: 'WP7', label: 'WP7', url: ICS_BASE + 'wp7.ics', color: '#e377c2' },
    { id: 'WP8', label: 'WP8', url: ICS_BASE + 'wp8.ics', color: '#7f7f7f' },
    { id: 'WP9', label: 'WP9', url: ICS_BASE + 'wp9.ics', color: '#17becf' },
    { id: 'HOLIDAYS', label: 'Holidays', url: ICS_BASE + 'holidays.ics', color: '#111827' }
  ];

  const STORAGE_KEY = 'emerge_timeline_toggles_v1';
  const INDEX_URL = 'index.html';

  // ---------------------------
  // Return to index with current toggle state
  // ---------------------------
  function buildIndexUrlFromToggles() {
    const enabled = FEEDS.map(f => f.id).filter(id => toggleState[id] === true);
    if (enabled.length === FEEDS.length) return INDEX_URL;

    const params = new URLSearchParams();
    params.set('show', enabled.join(','));
    return INDEX_URL + '?' + params.toString();
  }

  function updateHomeLinkHref() {
    const home = document.getElementById('homeLink');
    if (home) home.href = buildIndexUrlFromToggles();
  }

  // ---------------------------
  // Status + library checks
  // ---------------------------
  const statusEl = document.getElementById('status');
  function setError(msg) { statusEl.textContent = msg; statusEl.classList.add('error'); }

  if (!window.vis || !vis.DataSet || !vis.Timeline) {
    setError('Timeline libraries failed to load. Check that /vendor/moment.min.js, /vendor/vis-data.min.js and /vendor/vis-timeline-graph2d.min.js load with HTTP 200, then review the browser console for blocked-script errors.');
    throw new Error('vis libraries missing');
  }

  // ---------------------------
  // ICS parsing
  // ---------------------------
  function parseICS(icsText) {
    const rawLines = icsText.split(/\r?\n/);
    const lines = [];
    for (const line of rawLines) {
      if (!line) continue;
      if (line.startsWith(' ') || line.startsWith('\t')) {
        if (lines.length > 0) lines[lines.length - 1] += line.slice(1);
      } else {
        lines.push(line);
      }
    }

    const vevents = [];
    let current = null;

    for (const line of lines) {
      if (line.startsWith('BEGIN:VEVENT')) { current = {}; continue; }
      if (line.startsWith('END:VEVENT')) { if (current) vevents.push(current); current = null; continue; }
      if (!current) continue;

      const parts = line.split(':');
      if (parts.length < 2) continue;
      const value = parts.slice(1).join(':');
      const key = parts[0].split(';')[0].toUpperCase();

      if (key === 'SUMMARY') current.summary = value;
      if (key === 'DESCRIPTION') current.description = value.replace(/\\n/g, '\n');
      if (key === 'LOCATION') current.location = value;
      if (key === 'DTSTART') current.dtstart = value;
      if (key === 'DTEND') current.dtend = value;
    }

    function parseICSTime(v) {
      if (!v) return null;

      if (v.length === 8 && !v.includes('T')) {
        const y = parseInt(v.slice(0,4), 10);
        const m = parseInt(v.slice(4,6), 10) - 1;
        const d = parseInt(v.slice(6,8), 10);
        return { date: new Date(Date.UTC(y, m, d)), allDay: true };
      }

      const y = parseInt(v.slice(0,4), 10);
      const m = parseInt(v.slice(4,6), 10) - 1;
      const d = parseInt(v.slice(6,8), 10);
      const hh = parseInt(v.slice(9,11) || '0', 10);
      const mm = parseInt(v.slice(11,13) || '0', 10);
      const ss = parseInt(v.slice(13,15) || '0', 10);

      if (v.endsWith('Z')) return { date: new Date(Date.UTC(y, m, d, hh, mm, ss)), allDay: false };
      return { date: new Date(y, m, d, hh, mm, ss), allDay: false };
    }

    return vevents.map(ev => {
      const startParsed = parseICSTime(ev.dtstart);
      const endParsed = parseICSTime(ev.dtend);
      return {
        title: ev.summary || '(no title)',
        start: startParsed ? startParsed.date : null,
        end: endParsed ? endParsed.date : null,
        allDay: startParsed ? startParsed.allDay : false,
        description: ev.description || '',
        location: ev.location || ''
      };
    }).filter(e => e.start);
  }

  function formatDateRange(start, end, allDay) {
    if (!start) return 'Unknown';
    const optionsDate = { year: 'numeric', month: 'short', day: 'numeric' };
    const optionsTime = { hour: '2-digit', minute: '2-digit' };

    if (allDay) {
      if (end) return start.toLocaleDateString(undefined, optionsDate) + ' – ' + end.toLocaleDateString(undefined, optionsDate);
      return start.toLocaleDateString(undefined, optionsDate) + ' (all day)';
    }

    let text = start.toLocaleDateString(undefined, optionsDate) + ' ' + start.toLocaleTimeString(undefined, optionsTime);
    if (end) text += ' – ' + end.toLocaleTimeString(undefined, optionsTime);
    return text;
  }

  // ---------------------------
  // Contrast helper
  // ---------------------------
  function hexToRgb(hex) {
    const h = (hex || '').replace('#','').trim();
    if (h.length === 3) return { r: parseInt(h[0]+h[0],16), g: parseInt(h[1]+h[1],16), b: parseInt(h[2]+h[2],16) };
    if (h.length === 6) return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
    return { r:255, g:255, b:255 };
  }

  function relativeLuminance({r,g,b}) {
    const srgb = [r,g,b].map(v => {
      const x = v / 255;
      return x <= 0.03928 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
  }

  function bestTextColor(bgHex) {
    return relativeLuminance(hexToRgb(bgHex)) < 0.45 ? '#ffffff' : '#111111';
  }

  // ---------------------------
  // URL presets & persisted toggles
  // ---------------------------
  function getUrlParams() {
    const p = new URLSearchParams(window.location.search);
    const show = (p.get('show') || '').split(',').map(s => s.trim()).filter(Boolean);
    const hide = (p.get('hide') || '').split(',').map(s => s.trim()).filter(Boolean);
    return { show, hide };
  }

  function loadToggleState() {
    const base = Object.fromEntries(FEEDS.map(f => [f.id, true]));

    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        for (const k of Object.keys(base)) {
          if (typeof parsed[k] === 'boolean') base[k] = parsed[k];
        }
      }
    } catch (_) {}

    const { show, hide } = getUrlParams();
    if (show.length > 0) {
      for (const k of Object.keys(base)) base[k] = false;
      show.forEach(id => { if (id in base) base[id] = true; });
    }
    if (hide.length > 0) hide.forEach(id => { if (id in base) base[id] = false; });

    return base;
  }

  function saveToggleState(state) {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (_) {}
  }

  const toggleState = loadToggleState();

  document.getElementById('backBtn').addEventListener('click', () => {
    saveToggleState(toggleState);
    window.location.href = buildIndexUrlFromToggles();
  });

  // ---------------------------
  // Timeline setup
  // ---------------------------
  const container = document.getElementById('timeline');
  const groups = new vis.DataSet(FEEDS.map(f => ({ id: f.id, content: f.label, visible: true })));
  const items = new vis.DataSet();

  const timeline = new vis.Timeline(container, items, groups, {
    stack: true,
    horizontalScroll: true,
    zoomKey: 'ctrlKey',
    orientation: { axis: 'top' },
    margin: { item: 10, axis: 10 },
    showMajorLabels: true,
    showMinorLabels: true
  });

  function applyGroupVisibility() {
    FEEDS.forEach(f => groups.update({ id: f.id, visible: !!toggleState[f.id] }));
  }

  // ---------------------------
  // Weekend shading ONLY ON HOLIDAYS ROW, only when zoomed in
  // ---------------------------
  const WEEKEND_COLOR = getComputedStyle(document.documentElement)
    .getPropertyValue('--weekend').trim() || '#f0f2f5';

  const WEEKEND_MAX_DAYS_VISIBLE = 90; // show only when <= 90 days are visible
  const WEEKEND_GROUP_ID = 'HOLIDAYS'; // shade weekends on Holidays row only

  function startOfDay(d) {
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }

  function daysBetween(a, b) {
    return Math.abs(b - a) / (1000 * 60 * 60 * 24);
  }

  function buildWeekendBackgroundItems(rangeStart, rangeEnd) {
    const out = [];
    const start = startOfDay(rangeStart);
    const end = startOfDay(rangeEnd);

    // Expand slightly to cover partial weeks at edges
    start.setDate(start.getDate() - 7);
    end.setDate(end.getDate() + 7);

    // Find first Saturday on/after start
    const first = new Date(start);
    const day = first.getDay();                // 0 Sun ... 6 Sat
    const daysUntilSat = (6 - day + 7) % 7;
    first.setDate(first.getDate() + daysUntilSat);

    let i = 0;
    for (let d = new Date(first); d < end; d.setDate(d.getDate() + 7)) {
      const satStart = new Date(d);
      const monStart = new Date(d);
      monStart.setDate(monStart.getDate() + 2); // Sat+Sun -> end Monday 00:00

      out.push({
        id: `weekend-bg-${i++}`,
        group: WEEKEND_GROUP_ID,
        start: satStart,
        end: monStart,
        type: 'background',
        className: 'weekend-bg',
        style: `background-color:${WEEKEND_COLOR};border:none;`
      });
    }
    return out;
  }

  function removeWeekendItems() {
    const old = items.get({
      filter: (it) => typeof it.id === 'string' && it.id.startsWith('weekend-bg-')
    });
    if (old.length) items.remove(old.map(o => o.id));
  }

  function refreshWeekendShading() {
    const w = timeline.getWindow();
    const spanDays = daysBetween(w.start, w.end);

    if (spanDays > WEEKEND_MAX_DAYS_VISIBLE) {
      removeWeekendItems();
      timeline.redraw();
      return;
    }

    removeWeekendItems();
    items.add(buildWeekendBackgroundItems(w.start, w.end));
    timeline.redraw();
  }

  timeline.on('rangechange', refreshWeekendShading);
  timeline.on('rangechanged', refreshWeekendShading);

  // Controls
  document.getElementById('zoomInBtn').addEventListener('click', () => {
    const range = timeline.getWindow();
    const interval = range.end - range.start;
    timeline.setWindow({
      start: new Date(range.start.valueOf() + interval * 0.2),
      end: new Date(range.end.valueOf() - interval * 0.2)
    });
  });

  document.getElementById('zoomOutBtn').addEventListener('click', () => {
    const range = timeline.getWindow();
    const interval = range.end - range.start;
    timeline.setWindow({
      start: new Date(range.start.valueOf() - interval * 0.25),
      end: new Date(range.end.valueOf() + interval * 0.25)
    });
  });

  document.getElementById('fitBtn').addEventListener('click', () => timeline.fit());

  document.getElementById('yearBtn').addEventListener('click', () => {
    const now = new Date();
    const y = now.getFullYear();
    timeline.setWindow(new Date(y, 0, 1), new Date(y, 11, 31, 23, 59, 59));
  });

  // ---------------------------
  // Toggle UI
  // ---------------------------
  const togglebar = document.getElementById('togglebar');

  function renderToggles() {
    togglebar.innerHTML = '';
    for (const feed of FEEDS) {
      const label = document.createElement('label');
      label.className = 'toggle';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!toggleState[feed.id];
      cb.addEventListener('change', () => {
        toggleState[feed.id] = cb.checked;
        saveToggleState(toggleState);
        applyGroupVisibility();
        updateHomeLinkHref();
        setTimeout(() => timeline.redraw(), 0);
      });

      const swatch = document.createElement('span');
      swatch.className = 'swatch';
      swatch.style.background = feed.color;

      const text = document.createElement('span');
      text.textContent = feed.label;

      label.appendChild(cb);
      label.appendChild(swatch);
      label.appendChild(text);
      togglebar.appendChild(label);
    }
  }

  document.getElementById('showAllBtn').addEventListener('click', () => {
    FEEDS.forEach(f => toggleState[f.id] = true);
    saveToggleState(toggleState);
    renderToggles();
    applyGroupVisibility();
    updateHomeLinkHref();
  });

  document.getElementById('hideAllBtn').addEventListener('click', () => {
    FEEDS.forEach(f => toggleState[f.id] = false);
    saveToggleState(toggleState);
    renderToggles();
    applyGroupVisibility();
    updateHomeLinkHref();
  });

  renderToggles();
  applyGroupVisibility();
  updateHomeLinkHref();

  // ---------------------------
  // Modal
  // ---------------------------
  const modalBackdrop = document.getElementById('eventModalBackdrop');
  const modalTitle = document.getElementById('modalTitle');
  const modalWhen = document.getElementById('modalWhen');
  const modalSource = document.getElementById('modalSource');
  const modalLocation = document.getElementById('modalLocation');
  const modalDescription = document.getElementById('modalDescription');
  const modalCloseBtn = document.getElementById('modalCloseBtn');
  const modalOkBtn = document.getElementById('modalOkBtn');

  function closeModal() { modalBackdrop.classList.remove('show'); }
  modalCloseBtn.addEventListener('click', closeModal);
  modalOkBtn.addEventListener('click', closeModal);
  modalBackdrop.addEventListener('click', (e) => { if (e.target === modalBackdrop) closeModal(); });

  timeline.on('select', function(props) {
    if (!props.items || props.items.length === 0) return;
    const id = props.items[0];
    const item = items.get(id);
    if (!item) return;

    modalTitle.textContent = item.title || item.content || '(no title)';
    modalWhen.textContent = formatDateRange(item.start, item.end, item.allDay);
    modalSource.textContent = item.group || '—';
    modalLocation.textContent = item.location || 'Not specified';
    modalDescription.textContent = item.description || 'No description provided.';
    modalBackdrop.classList.add('show');
  });

  // ---------------------------
  // Load feeds
  // ---------------------------
  async function loadFeed(feed) {
    const resp = await fetch(feed.url, { cache: 'no-store' });
    if (!resp.ok) throw new Error(feed.id + ' HTTP ' + resp.status);

    const text = await resp.text();
    const evs = parseICS(text);

    const bg = feed.color;
    const fg = bestTextColor(bg);
    const style = `background-color:${bg};border-color:${bg};color:${fg};`;

    return evs.map((ev, idx) => {
      const hasEnd = !!ev.end;
      return {
        id: feed.id.toLowerCase() + '-' + idx,
        group: feed.id,
        content: ev.title,
        title: ev.title,
        start: ev.start,
        end: hasEnd ? ev.end : undefined,
        type: hasEnd ? 'range' : 'point',
        allDay: ev.allDay,
        description: ev.description,
        location: ev.location,
        style
      };
    });
  }

  async function loadTimeline() {
    statusEl.textContent = 'Loading timeline from ICS feeds…';
    statusEl.classList.remove('error');

    const results = [];
    const errors = [];

    for (const feed of FEEDS) {
      try {
        const itemsForFeed = await loadFeed(feed);
        results.push({ id: feed.id, count: itemsForFeed.length, items: itemsForFeed });
      } catch (e) {
        console.error('Feed load failed:', feed.id, e);
        errors.push(feed.id + ': ' + (e && e.message ? e.message : e));
      }
    }

    items.clear();
    for (const r of results) for (const it of r.items) items.add(it);

    const total = results.reduce((sum, r) => sum + r.count, 0);

    if (errors.length > 0) {
      setError('Loaded ' + total + ' items, but some feeds failed: ' + errors.join(' | '));
    } else {
      statusEl.textContent = 'Timeline loaded (' + total + ' items across ' + FEEDS.length + ' feeds).';
    }

    if (total > 0) timeline.fit();

    // Apply weekend shading for current window (if zoomed-in enough)
    setTimeout(refreshWeekendShading, 0);
  }

  loadTimeline();
</script>
</body>
</html>
